# -*- coding: utf-8 -*-
r"""
    This module contains all evolution operator classes.

    See :doc:`Operator overview </Code/Operators>`.
"""

import time
import logging

import numpy as np

from . import mellin
from . import kernels

from .operator.member import OperatorMember
from .operator.physical import PhysicalOperator

logger = logging.getLogger(__name__)


class Operator:
    """
    Internal representation of a single EKO.

    The actual matrices are computed only upon calling :meth:`compute`.
    :meth:`compose` will generate the :class:`PhysicalOperator` for the outside world.
    If not computed yet, :meth:`compose` will call :meth:`compute`.

    Parameters
    ----------
        master : eko.operator_grid.OperatorMaster
            the master instance
        q2_from : float
            evolution source
        q2_to : float
            evolution target
        mellin_cut : float
            cut to the upper limit in the mellin inversion
    """

    def __init__(self, master, q2_from, q2_to, mellin_cut=1e-2):
        self.master = master
        self.q2_from = q2_from
        self.q2_to = q2_to
        # TODO make 'cut' external parameter?
        self._mellin_cut = mellin_cut
        self.op_members = {}

    @property
    def xgrid(self):
        """ underlying basis grid """
        return self.master.grid.managers[
            "kernel_dispatcher"
        ].interpol_dispatcher.xgrid_raw

    def compose(self, op_list, instruction_set, q2_final):
        """
        Compose all :class:`Operator` together.

        Calls :meth:`compute`, if necessary.

        Parameters
        ----------
            op_list : list(Operator)
                list of operators to merge
            instruction_set : dict
                list of instructions (generated by :class:`eko.thresholds.FlavourTarget`)
            q2_final : float
                final scale

        Returns
        -------
            op : PhysicalOperator
                final operator
        """
        # compute?
        if len(self.op_members.keys()) == 0:
            self.compute()
        # prepare operators
        op_to_compose = [self.op_members] + [i.op_members for i in reversed(op_list)]
        # iterate operators
        new_ops = {}
        for name, instructions in instruction_set:
            for origin, paths in instructions.items():
                key = f"{name}.{origin}"
                op = OperatorMember.join(op_to_compose, paths)
                # enforce new name
                op.name = key
                new_ops[key] = op
        return PhysicalOperator(new_ops, q2_final)

    def labels(self):
        """
        Compute necessary sector labels to compute.

        Returns
        -------
            labels : list(str)
                sector labels
        """
        order = self.master.grid.managers["kernel_dispatcher"].config["order"]
        labels = []
        # NS sector is dynamic
        if not self.master.grid.config["debug_skip_non_singlet"]:
            labels.append("NS_p")
            if order > 0:
                labels.append("NS_m")
        # singlet sector is fixed
        if not self.master.grid.config["debug_skip_singlet"]:
            labels.extend(["S_qq", "S_qg", "S_gq", "S_gg"])
        return labels

    def compute(self):
        """ compute the actual operators (i.e. run the integrations) """
        # Generic parameters
        grid_size = len(self.xgrid)

        # init all ops with zeros
        singlet_names = ["S_qq", "S_qg", "S_gq", "S_gg"]
        ns_names = ["NS_p", "NS_m", "NS_v"]
        for n in singlet_names + ns_names:
            self.op_members[n] = OperatorMember(
                np.zeros((grid_size, grid_size)), np.zeros((grid_size, grid_size)), n
            )
        tot_start_time = time.perf_counter()
        # setup KernelDispatcher
        logger.info("Evolution: computing operators - 0/%d", grid_size)
        sc = self.master.grid.managers["strong_coupling"]
        a1 = sc.a_s(self.q2_to)
        a0 = sc.a_s(self.q2_from)
        kd = self.master.grid.managers["kernel_dispatcher"]
        # determine labels
        labels = self.labels()
        # iterate output grid
        for k, logx in enumerate(np.log(self.xgrid)):
            start_time = time.perf_counter()
            # kd.var["logx"] = logx
            # iterate basis functions
            for l, bf in enumerate(kd.interpol_dispatcher):
                # kd.var["areas"] = bf.areas_representation,
                # iterate sectors
                for label in labels:
                    # kd.obj.mode = label
                    # compute and set
                    val, err = mellin.inverse_mellin_transform(
                        kernels.quad_ker,
                        self._mellin_cut,
                        [
                            kd.config["order"],
                            label,
                            kd.config["method"],
                            kd.interpol_dispatcher.log,
                            logx,
                            bf.areas_representation,
                            a1,
                            a0,
                            self.master.nf,
                            kd.config["ev_op_iterations"],
                            kd.config["ev_op_max_order"],
                        ],
                    )
                    self.op_members[label].value[k][l] = val
                    self.op_members[label].error[k][l] = err

            logger.info(
                "Evolution: computing operators - %d/%d took: %f s",
                k + 1,
                grid_size,
                time.perf_counter() - start_time,
            )

        # copy non-singlet kernels, if necessary
        order = kd.config["order"]
        if order == 0:  # in LO +=-=v
            for label in ["NS_v", "NS_m"]:
                self.op_members[label].value = self.op_members["NS_p"].value.copy()
                self.op_members[label].error = self.op_members["NS_p"].error.copy()
        elif order == 1:  # in NLO -=v
            self.op_members["NS_v"].value = self.op_members["NS_m"].value.copy()
            self.op_members["NS_v"].error = self.op_members["NS_m"].error.copy()
        # closing comment
        logger.info("Evolution: Total time %f s", time.perf_counter() - tot_start_time)
